# 2024-03-03

---

### 오늘 해야 할 것

##### 1. SQLD 노랭이 2과목 1장 []

### 배운점

##### 1. 트랜잭션 격리 수준

(1) 트랜잭션 격리 수준의 필요성 : 동시성 문제를 해결하기 위함
=> 여러 트랜잭션이 동시에 실행됐더라도 그 결과가 트랜잭션이 순차적으로 실행됐을 때의 결과와 동일함을 보장

(2) 트랜잭션 격리 수준과 문제점

- [격리수준] Read Uncommitted (커밋 전 읽기)

  - 다른 트랜잭션에서 커밋되지 않은 데이터를 읽음
  - 발생 가능 문제 : Dirty Read, Non-Repeatable Read, Phantom Read

- [문제점] Dirty Read : 다른 트랜잭션에 의해 수정됐지만 아직 커밋되지 않은 데이터를 읽는 것

  - 해결 방법 : 커밋된 데이터만 읽기

- [격리수준] Read Committed (커밋 후 읽기) => 기본적인 격리 수준

  - DB에서 읽을 때 커밋된 데이터만 읽는다.(Dirty read 가 없음) 을 보장
  - DB에 쓸 때 커밋된 데이터만 덮어쓴다.(Dirty write 가 없음) 을 보장
  - 발생 가능 문제 : Non-Repeatable Read, Phantom Read

- [문제점] Non-Repeatable Read : 한 트랜잭션 내에서
  ex)

  > > 고객 A는 인터넷 뱅킹을 통해 자신의 계좌 잔액을 조회한다. 이 시점에서 잔액은 1,000,000원. 이와 동시에, 고객 B가 같은 은행의 다른 창구에서 A의 계좌로부터 500,000원을 출금한다. B의 출금 트랜잭션이 완료되어 데이터베이스에 반영된다.
  > > 이후 고객 A가 다시 잔액을 조회했을 때, 잔액이 500,000원으로 변경된 것을 확인한다. A는 같은 트랜잭션 내에서 두 번의 조회 결과가 다르게 나타났음을 확인한다.

- Repeatable Read (반복 읽기)

- Serializable : 트랜잭션들을 직렬화하여 실행하여, 하나의 트랜잭션이 완전히 종료된 후에 다음 트랜잭션이 실행되도록 한다.
  ex)

  > > 고객 A가 Serializable 격리 수준에서 거래 내역을 조회하고 있는 동안, 이 트랜잭션이 완료되기 전까지는 고객 B는 새로운 거래를 추가할 수 없다. A의 조회 트랜잭션이 완료된 후에만 B의 새로운 거래 추가가 가능해진다. 결과적으로, A는 자신의 트랜잭션 동안 일관된 데이터 뷰를 유지할 수 있으며, Phantom Read 문제가 발생하지 않는다.

  ==> 모든 격리 문제 해결
  ==> 하지만 Serializable 격리 수준은 트랜잭션 처리 성능에 큰 영향을 줄 수 있으며, 동시성이 높은 환경에서는 대기 시간이 증가하고, 교착 상태가 발생할 가능성이 높아진다. 따라서, 이 격리 수준은 필요한 경우에만 사용해야한다.


### 내일 해야 할 것
