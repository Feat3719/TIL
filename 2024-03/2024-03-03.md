# 2024-03-03

---

### 📌 오늘 해야 할 것

##### 1. SQLD 노랭이 2과목 1장 [✅]

### 🤙내일 해야 할 것

- SQLD 노랭이 2과목 2장

### ✍️ 오늘 배운점

##### 1. 트랜잭션 격리 수준

(1) 트랜잭션 격리 수준의 필요성 : 동시성 문제를 해결하기 위함
=> 여러 트랜잭션이 동시에 실행됐더라도 그 결과가 트랜잭션이 순차적으로 실행됐을 때의 결과와 동일함을 보장

(2) 트랜잭션 격리 수준과 문제점

- [격리수준] Read Uncommitted (커밋 전 읽기)

  - 다른 트랜잭션에서 커밋되지 않은 데이터를 읽음
  - 발생 가능 문제 : Dirty Read, Non-Repeatable Read, Phantom Read

- [문제점] Dirty Read : 다른 트랜잭션에 의해 수정됐지만 아직 커밋되지 않은 데이터를 읽는 것

  - 해결 방법(대부분 기본적으로 설정이 되어 있음)
    - Read Committed 격리 수준으로 설정
    - 읽기 및 쓰기 잠금(Locking 메커니즘 활용) 설정
    - 트랜잭션의 커밋과 롤백을 명확화
    - DBMS 구성 옵션을 조정

- [격리수준] Read Committed (커밋 후 읽기) => 기본적인 격리 수준

  - DB에서 읽을 때 커밋된 데이터만 읽는다.(Dirty read 가 없음) 을 보장
  - DB에 쓸 때 커밋된 데이터만 덮어쓴다.(Dirty write 가 없음) 을 보장
  - 발생 가능 문제 : Non-Repeatable Read, Phantom Read

- [문제점] Non-Repeatable Read : 한 트랜잭션 내에서 같은 쿼리를 두 번 실행했을 때 다른 결과를 받는 경우
  ex)

  > > 고객 A는 인터넷 뱅킹을 통해 자신의 계좌 잔액을 조회한다. 이 시점에서 잔액은 1,000,000원. 이와 동시에, 고객 B가 같은 은행의 다른 창구에서 A의 계좌로부터 500,000원을 출금한다. B의 출금 트랜잭션이 완료되어 데이터베이스에 반영된다.
  > > 이후 고객 A가 다시 잔액을 조회했을 때, 잔액이 500,000원으로 변경된 것을 확인한다. A는 같은 트랜잭션 내에서 두 번의 조회 결과가 다르게 나타났음을 확인한다.

  - 해결 방법
    - Repeatable Read 격리 수준으로 설정
    - Locking 기법(Locking 메커니즘 활용) : 데이터베이스는 트랜잭션이 데이터를 읽을 때 해당 데이터에 대한 잠금(lock)을 설정할 수 있다. Repeatable Read 격리 수준에서는 트랜잭션이 데이터를 읽을 때 해당 데이터에 대한 읽기 잠금(read lock)을 걸어, 다른 트랜잭션이 해당 데이터를 변경할 수 없도록 한다. 이러한 잠금은 트랜잭션이 종료될 때까지 유지된다.

- [격리수준] Repeatable Read (반복 읽기) : 한 트랜잭션 내에서 같은 데이터를 여러 번 읽어도 첫 번째 읽은 시점의 데이터와 동일한 결과를 반환하도록 보장한다.

  - 발생 가능 문제 : Phantom Read

- [문제점] Phantom Read : 한 트랜잭션 내에서 같은 쿼리를 두 번 실행했을 때, 첫 번째 쿼리에서는 보이지 않았던 새로운 행(또는 데이터)이 두 번째 쿼리 결과에 포함되는 경우.
  ex)

  > > 고객 A는 특정 조건(예: 잔액이 1,000,000원 이상인 모든 계좌)에 맞는 계좌를 조회한다. 이 시점에서 계좌는 3개가 조회된다. 이와 동시에, 다른 고객 B가 새로운 계좌를 개설하고, 잔액을 1,500,000원으로 설정한다. B의 계좌 개설 트랜잭션이 완료되어 데이터베이스에 반영된다.
  > > 이후 고객 A가 다시 동일한 조건으로 계좌를 조회했을 때, 새로 개설된 B의 계좌까지 포함하여 4개의 계좌가 조회된다. A는 같은 트랜잭션 내에서 두 번의 조회 결과가 다르게 나타났음을 확인한다.

- [격리수준] Serializable : 트랜잭션들을 직렬화하여 실행하여, 하나의 트랜잭션이 완전히 종료된 후에 다음 트랜잭션이 실행되도록 한다.
  ex)

  > > 고객 A가 Serializable 격리 수준에서 거래 내역을 조회하고 있는 동안, 이 트랜잭션이 완료되기 전까지는 고객 B는 새로운 거래를 추가할 수 없다. A의 조회 트랜잭션이 완료된 후에만 B의 새로운 거래 추가가 가능해진다. 결과적으로, A는 자신의 트랜잭션 동안 일관된 데이터 뷰를 유지할 수 있으며, Phantom Read 문제가 발생하지 않는다.

  ==> 모든 격리 문제 해결
  ==> 하지만 Serializable 격리 수준은 트랜잭션 처리 성능에 큰 영향을 줄 수 있으며, 동시성이 높은 환경에서는 대기 시간이 증가하고, 교착 상태가 발생할 가능성이 높아진다. 따라서, 이 격리 수준은 필요한 경우에만 사용해야한다.
